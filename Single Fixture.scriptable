
/*위젯 크기 small, medium*/
const widgetSize = config.widgetFamily || 'medium'

// 리그 이름
var league_nm = ''

// 캘린더 ID

const textSize = 9.5
const logoSize = 38
const logoSmallSize = 22
const spacing = { normal: 8, smaller: 6, vs: 5, widget: 10 }

var resetmode = 0

const orgData = {
  team_init_name : "",
  team_full_name : "",
  team_img_src : "",
  cal_id : "",
  dark_mode : true
}

var teamDataURL
var teamAllData
var teamList
var usrData

var myTeamInfo
var data
var car_url = 'http://kfpl.kr/wp-json/sportspress/v2/calendars/'


/*파일 설정*/
let tempFm = FileManager.local()
let tempPath = tempFm.joinPath(tempFm.documentsDirectory(), "kfplConfig.txt")

if(!tempFm.fileExists(tempPath))
{
	if(config.runsInWidget)
	{
		let errorWidget = new ListWidget()
		let title = errorWidget.addText("앱 내에서 위젯을 실행해 주세요.\nPlease run the widget in the app.")
		title.font = Font.boldMonospacedSystemFont(16)
		errorWidget.backgroundColor = new Color("#4661a3")
		Script.setWidget(errorWidget)
		return 0
	}
  
	var dataPath = "local"
	var language = "ko"
  
	tempFm.writeString(tempPath, language + "," + dataPath)
}

var configData = tempFm.readString(tempPath)
var dataPath = configData.split(",")[1]
var language = configData.split(",")[0]


var fm
fm = FileManager.local()

const prefPath = fm.joinPath(fm.documentsDirectory(), "kfpl.txt")

if(!fm.fileExists(prefPath))
{
	let alert = new Alert()
	alert.title = language == "ko" ? "환영합니다!" : "Welcome!"
	alert.message = language == "ko" ? "KFPL 위젯을 사용해 주셔서 감사합니다. \nDeveloped by GXNZIO" : "welcome"
	alert.addAction(language == "ko" ? "확인" : "OK")
	await alert.present()
	fm.writeString(prefPath, JSON.stringify(orgData))
}



if(config.runsInApp) 
{

	let menu = new UITable()
	menu.showSeparators = true
  
	usrData = JSON.parse(fm.readString(prefPath))
  
	// Auto Update Preferences
	var cnt = 0
	for(i in orgData)
	{
		if(usrData[i] == undefined)
		{
			cnt = cnt + 1
			usrData[i] = orgData[i]
			console.log("[!] Updating Preferences... (" + cnt + ")")
		}
	}  

	teamDataURL = "https://raw.githubusercontent.com/cnasc83/kfpl_repo/main/SINGLE.json"
	teamAllData = await new Request(teamDataURL).loadJSON()
	teamList = teamAllData.teamlist		
	usrData.cal_id = teamAllData.cal_id
	league_nm = teamAllData.league_nm
	
	const option1 = new UITableRow()
	option1.dismissOnSelect = false
	option1.addText("나의 팀 설정")
	menu.addRow(option1)
  
  	option1.onSelect = async () => {
  	
		teamDataURL = "https://raw.githubusercontent.com/cnasc83/kfpl_repo/main/SINGLE.json"
		teamAllData = await new Request(teamDataURL).loadJSON()
		teamList = teamAllData.teamlist
		usrData.cal_id = teamAllData.cal_id
		
		let teamSetMenu = new UITable()
		teamSetMenu.showSeparators = true
    
		var FinalTeamArr = teamList
    
		for(reg in FinalTeamArr)
		{
			const regOption = new UITableRow()
			regOption.dismissOnSelect = true
			regOption.addText(FinalTeamArr[reg].full_name)
			teamSetMenu.addRow(regOption)
			
			regOption.onSelect = async (reg) => {
				
				usrData["team_init_name"] = FinalTeamArr[reg].init_name
				usrData["team_full_name"] = FinalTeamArr[reg].full_name
				usrData["team_img_src"] = FinalTeamArr[reg].img_src

				let teamSetAlert = new Alert()
				teamSetAlert.title = "팀 선택"
				teamSetAlert.message = "나의 팀이 " + FinalTeamArr[reg].full_name + "로 설정되었습니다."
				teamSetAlert.addAction("확인")
				await teamSetAlert.present()
			}
		}
		await teamSetMenu.present()
	}

	
	const option2 = new UITableRow()
	option2.dismissOnSelect = false
	option2.addText("다크모드 설정")
	menu.addRow(option2)	
	
	option2.onSelect = async () => {

		let darkYN = new Alert()
		darkYN.title = "위젯 다크모드 사용 설정"
		darkYN.message = "다크모드 기능입니다."
		darkYN.addAction("사용")
		darkYN.addCancelAction("미사용")

		if(await darkYN.present() != -1)
		{
			usrData.dark_mode = true
			
		}else{
			usrData.dark_mode = false
		}

	}
  

	const option3 = new UITableRow()
	option3.dismissOnSelect = true
	option3.addText("데이터 초기화")
	menu.addRow(option3)
  
	option3.onSelect = async () => {
		resetmode = 1
		let resetAlert = new Alert()
		resetAlert.title = "나의 팀 정보 삭제"
		resetAlert.message = "초기화 하시겠습니까?" 
		resetAlert.addDestructiveAction("초기화")
		resetAlert.addCancelAction("취소")
    
		if(await resetAlert.present() != -1){
			fm.remove(prefPath)
			
			tempFm.remove(tempPath)
		}
	}
	
	await menu.present(false)
	fm.writeString(prefPath, JSON.stringify(usrData))
  
}


if(resetmode){ return 0 }

const fetchData = async (url, type = 'loadJSON') => {
  const request = new Request(url)
  const res = await request[type]()
  return res
}

usrData = JSON.parse(fm.readString(prefPath))

teamDataURL = "https://raw.githubusercontent.com/cnasc83/kfpl_repo/main/SINGLE.json"

teamAllData = await new Request(teamDataURL).loadJSON()
teamList = teamAllData.teamlist		
usrData.cal_id = teamAllData.cal_id

/* 전체팀 정보 (이니셜, 풀네임, 로고) */
const getTeamInfo = async (string) => {
	
	var teamArr = teamList
	
	for(num in teamArr)
	{
		if(teamArr[num].init_name == string || teamArr[num].full_name == string)
		{
			return {
			       teamInitName: teamArr[num].init_name,
				teamFullName: teamArr[num].full_name,
				teamLogo: await fetchData(teamArr[num].img_src, 'loadImage')
			}
		}
	}	
}


const convDatetoTimestamp = (datetime) => {
	/*Fmt : 2021-02-18 14:00:00 */
	var year = datetime.substring(0,4)
	var month = datetime.substring(5,7)
	var day = datetime.substring(8,10)
	var hour = datetime.substring(11,13)
	var minute = datetime.substring(14,16)
	var second = datetime.substring(17,19)
	var datum = new Date(year,month-1,day,hour,minute,second)
	return datum. getTime()/1000
}

const getFormattedDate = (timestamp, useToday = true) => {
  const millisPerDay = 24 * 60 * 60 * 1000
  const formats = [
    "yyyy.M.d 'at' HH:mm",
    "'Tomorrow at' HH:mm",
    "'Today at' HH:mm",
  ]
  const date = new Date(timestamp*1000)
  const matchDay = (new Date(date)).setHours(0, 0, 0, 0)
  const today = (new Date()).setHours(0, 0, 0, 0)
  const diff = (matchDay - today) / millisPerDay
  const format = useToday ? (diff < 1 ? 2 : diff < 2 ? 1 : 0) : 0
  const dateFormatter = new DateFormatter()
  dateFormatter.dateFormat = formats[format]
  return dateFormatter.string(date)
}

/* 전체일정 > 마이팀 일정 가져오기 */
const getTeamEventsData = async () => {

	myTeamInfo = await getTeamInfo(usrData.team_init_name)
	data = await fetchData(car_url+usrData.cal_id)
	
	/*캘린더 일정가져오기*/
	var matchList = new Array()
	for (var key in data.data) {
		const matchDay = data.data[key]
		matchList.push(matchDay)
	}

       /*경기 예정분 가져오기*/
	var todayMatchIdList = new Array()
	for (var day in matchList) {
		const match_info = matchList[day]
    
		if(match_info.post_status == 'future')
		//if(match_info.post_status == 'publish')
		{
			todayMatchIdList.push(match_info)
		}
	}  

	/*나의 팀 일정 가져오기*/
	var teamTodayMatchList = new Array()

	for (var id in todayMatchIdList) 
	{
		const today_match_info = todayMatchIdList[id]	
		
		if(today_match_info.post_title.includes(usrData.team_full_name))
		{
			teamTodayMatchList.push(today_match_info)
		}
	}

	teamTodayMatchList.sort(function(a,b) {
		return a.post_date > b.post_date
	})

	const nextMatchList = teamTodayMatchList.slice(0, 5)
	
	return nextMatchList
}

const getUpcomingEventData = async event => {

  var title = event.post_title.split('vs')
  var home = title[0].trim()
  var away = title[1].trim()
  
  var home_info = await getTeamInfo(home)
  var away_info = await getTeamInfo(away)
  
  return {
    competition: league_nm,
    homeLogo: home_info.teamLogo,
    awayLogo: away_info.teamLogo,
    homeTeam: home,
    awayTeam: away,
    date : event.post_date
  }
}

const getRestEventsData = async events => {
  const output = []
  for (const event of events) {
  
    const title = event.post_title.split('vs')
    const home = title[0].trim() 
    const away = title[1].trim()
    
    const home_info = await getTeamInfo(home)
    const away_info = await getTeamInfo(away)
  
    const isHomeTeam = home_info.teamInitName == usrData.team_init_name
    const team = isHomeTeam ? away_info : home_info
    
    output.push({
      competition: league_nm,
      logo: team.teamLogo,
      team: team.teamFullName,
      date: event.post_date,
      text: isHomeTeam ? '[H]' : '[A]',
    })
  }
  return output
}

	

const addText = (el, string, type) => {
  const text = el.addText(string)
  text.font = type === 'bold' ?
    Font.boldSystemFont(textSize * 1.2) :
    Font.regularSystemFont(textSize)
  text.textColor = new Color(usrData.dark_mode ? '#ffffff' : '#000000', 1)
  text.lineLimit = 1
  text.textOpacity = type === 'small' ? 0.5 : 1
  text.centerAlignText()
}

const addImage = (el, src, size = logoSize) => {
  const image = el.addImage(src)
  image.imageSize = new Size(size, size)
}

const addSpacer = (el, type) => {
  el.addSpacer(spacing[type])
}

const addStack = (el, type = 'horizontal', centered = false, size) => {
  const stack = el.addStack()
  if (type === 'vertical') stack.layoutVertically()
  else stack.layoutHorizontally()
  if (centered) stack.centerAlignContent()
  if (size) stack.size = size
  return stack
}

const addLogos = (el, homeLogo, awayLogo) => {
  const s = addStack(el, 'horizontal', true)
  addSpacer(s)
  addImage(s, homeLogo)
  addSpacer(s, 'vs')
  addText(s, 'vs')
  addSpacer(s, 'vs')
  addImage(s, awayLogo)
  addSpacer(s)
}

const initWidget = () => {
  const w = new ListWidget()
  w.backgroundColor = new Color(usrData.dark_mode ? '#1B1B1B' : '#FFFFFF', 1)
  w.setPadding(
    spacing.widget, spacing.widget,
    spacing.widget, spacing.widget,
  )
  return w
}

const addCenteredText = (el, text, type) => {
  const s = addStack(el, 'horizontal', true)
  addSpacer(s)
  addText(s, text, type)
  addSpacer(s)
}

const initUpcomingEvent = (el, event) => {
  addSpacer(el)
  addCenteredText(el, event.competition)
  addSpacer(el, 'normal')
  addLogos(el, event.homeLogo, event.awayLogo)
  addSpacer(el, 'normal')
  addCenteredText(el, event.homeTeam.toUpperCase(), 'bold')
  addCenteredText(el, event.awayTeam.toUpperCase(), 'bold')
  addSpacer(el, 'smaller')
  addCenteredText(el, getFormattedDate(convDatetoTimestamp(event.date)))
  //addCenteredText(el, event.stadium)
  addSpacer(el)
  
}

const initRestEvents = (el, events) => {
  events.forEach((data, idx) => {
    const hs = addStack(el, 'horizontal', true)
    addText(hs, data.text, 'small')
    addSpacer(hs, 'vs')
    addImage(hs, data.logo, logoSmallSize)
    addSpacer(hs, 'vs')
    const vs = addStack(hs, 'vertical')
    addText(vs, data.team.toUpperCase(), 'bold')
    addText(vs, getFormattedDate(convDatetoTimestamp(data.date), false), 'small')
    if (idx < 3) addSpacer(el, 'small')
  })
}

const createNextMatchWidget = async () => {
  const events = await getTeamEventsData()
  const widget = initWidget()
  if(events != ''){
	  if (widgetSize === 'small') {
	    const upcomingEventData = await getUpcomingEventData(events[0])
	    initUpcomingEvent(widget, upcomingEventData)
	  } else if (widgetSize === 'medium') {
		if(events != null){
			const upcomingEventData = await getUpcomingEventData(events[0])
			const restEventData = await getRestEventsData(events.slice(1, 5))
			const s = addStack(widget, 'horizontal', true)
			initUpcomingEvent(addStack(s, 'vertical', true, new Size(130, 135)), upcomingEventData)
			addSpacer(s, 'normal')
			initRestEvents(addStack(s, 'vertical', true, new Size(160, 135)), restEventData)
		}
	  }
  }
  return widget
}

const widget = await createNextMatchWidget()
Script.setWidget(widget)
await widget.presentMedium()
Script.complete()

